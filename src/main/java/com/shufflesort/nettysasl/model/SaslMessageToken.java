package com.shufflesort.nettysasl.model;

import org.jboss.netty.buffer.ChannelBuffer;
import org.jboss.netty.buffer.ChannelBufferOutputStream;
import org.jboss.netty.buffer.ChannelBuffers;

/**
 * Send and receive SASL tokens.
 */
public class SaslMessageToken {
    /** Used for client or server's token to send or receive from each other. */
    private byte[] token;

    /**
     * Constructor used for reflection only.
     */
    public SaslMessageToken() {
    }

    /**
     * Constructor used to send request.
     * 
     * @param token
     *            the SASL token, generated by a SaslClient or SaslServer.
     */
    public SaslMessageToken(final byte[] token) {
        this.token = token;
    }

    /**
     * encode the current SaslToken Message into a channel buffer
     * SaslTokenMessageRequest is encoded as: identifier .... short(2) always it
     * is -500 payload length .... int payload .... byte[]
     * 
     * @throws Exception
     */
    public ChannelBuffer buffer() throws Exception {
        final ChannelBufferOutputStream bout = new ChannelBufferOutputStream(
                ChannelBuffers.directBuffer(encodeLength()));
        final short identifier = -500;
        int payload_len = 0;
        if (token != null) {
            payload_len = token.length;
        }

        bout.writeShort(identifier);
        bout.writeInt(payload_len);
        if (payload_len > 0) {
            bout.write(token);
        }
        bout.close();
        return bout.buffer();
    }

    int encodeLength() {
        return 2 + 4 + token.length;
    }

    /**
     * Read accessor for SASL token
     * 
     * @return saslToken SASL token
     */
    public byte[] getSaslToken() {
        return token;
    }

    /**
     * Write accessor for SASL token
     * 
     * @param token
     *            SASL token
     */
    public void setSaslToken(final byte[] token) {
        this.token = token;
    }
}
